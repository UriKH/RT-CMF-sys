from utils.util_types import *
from utils.plane import Plane
from configs.analysis import *
from ramanujantools.cmf import CMF
from analysis_stage.subspaces.shard.shard import Shard
from utils.point_generator import PointGenerator

from itertools import product
from functools import lru_cache
from scipy.optimize import linprog
import numpy as np
from numpy import linalg
from tqdm import tqdm


class ShardExtractor:
    """
    A functional class in charge of the Shards extraction for later use
    """
    def __init__(self, cmf: CMF, shifts: Position):
        self.cmf: CMF = cmf
        self.shifts: Position = shifts
        self.hps, self.symbols = self.__extract_shard_hyperplanes(cmf)

        # This will be instantiated later on the first call to get_encoded_shards()
        self._mono_shard = len(self.hps) == 0
        self._encoded_shards = [tuple()] if self._mono_shard else None
        self._feasible_points = [[0] * len(self.symbols)] if self._mono_shard else None
        self._shards = [Shard(tuple(), self)] if self._mono_shard else None

    @staticmethod
    def __extract_shard_hyperplanes(cmf: CMF) -> Tuple[List[Plane], List[sp.Symbol]]:
        """
        Extract the CMF's hyperplanes that form the shards
        :param cmf: The CMF to analyze
        :return: the list of sympy expressions describing the hyperplanes and a list of the symbols
        """

        def solve_shards(mat: sp.Matrix) -> Tuple[Set[EqTup], Set[EqTup]]:
            """
            Find the expressions for which the matrix is undefined or its determinant is 0
            :param mat: The matrix to preform the calculations on
            :return: The list of expressions for undefined hyperplanes (lhs, rhs);
            The list of expressions for zero determinant hyperplanes (lhs, rhs)
            """
            l = []
            for v in mat.iter_values():
                if (den := v.as_numer_denom()[1]) == 1:
                    continue
                l += [{sym: sol} for sym in den.free_symbols for sol in sp.solve(den, sym)]
            return freeze(l), freeze(sp.solve(mat.det()))

        def freeze(l: List[Dict]) -> Set[EqTup]:
            """
            Convert a list of dictionaries generated by sympy.solve() into a set of lhs, rhs tuples
            :param l: The list of dictionaries to transform
            :return: The transformed list
            """
            return set(tuple(set(sol.items()))[0] for sol in l)

        def unfreeze(l: Set[EqTup]) -> List[EqTup]:
            """
            Converts the set of tuples (lhs, rhs) into a list of tuples such that we won't have doubles (filtering).
            :param l: The list to "unfreeze"
            :return: The filtered list of tuples (lhs, rhs)
            """
            clean = [set(tup) for tup in l]
            new_lst = set(tuple(tup) for tup in clean)
            return list(new_lst)  # type checker shouts, but this is correct!

        data = set()
        for mat in cmf.matrices.values():
            undef, z_det = solve_shards(mat)
            data = data.union(z_det.union(undef))
        data = unfreeze(data)
        symbols = list(cmf.matrices.keys())
        return [Plane(exp1 - exp2, symbols) for exp1, exp2 in data], symbols

    def get_encoded_shards(self) -> List[ShardVec]:
        """
        Compute the Shards as Shard vector identifiers
        :return: A list of the vector identifiers
        """
        @lru_cache(maxsize=128 if SHARD_EXTRACTOR_CACHE else 0)
        def expr_to_ineq(expr, greater_than_0: bool = True):
            """
            Prepare a linear expression of the form: ax + b > 0 \n
            to the form scipy.linprog() receives: -ax <= b - err \n
            (similarly for ax + b < 0: ax <= -b - err)
            :param expr: The expression to transform into the relevant inequality
            :param greater_than_0: indicates the format
            :return: the row matching the expression and the constant in the scipy.linprog() format
            """
            coeffs = expr.as_coefficients_dict()
            sign = 1 if greater_than_0 else -1
            row = [-sign * coeffs.select(v, 0) for v in self.symbols]
            b = sign * coeffs.select(1, 0) - SHARD_EXTRACTOR_ERR
            return row, b

        def validate_shard(shard: ShardVec) -> Tuple[bool, List[int | float, ...]]:
            """
            Checks if a shard vector is valid in the CMF
            :param shard: the shard vector +-1's vector that describes the shard
            :return: True if a corresponding shard exists, else False
            """
            A, b = [], []
            for ineq, indicator in zip(self.hps, shard):
                row, rhs = expr_to_ineq(ineq.expression, indicator == 1)
                A.append(row)
                b.append(rhs)
            res = linprog(c=list(np.zeros(len(self.symbols))), A_ub=A, b_ub=b, method="highs")
            return res.success, res.x.tolist()

        if self._encoded_shards is not None:
            return self._encoded_shards

        if self._mono_shard:
            self._encoded_shards = [tuple()]
            self._feasible_points = [[0] * len(self.symbols)]
            return self._encoded_shards

        prems = product([+1, -1], repeat=len(self.hps))

        shards_validated = [
            (perm, val[1]) for perm in tqdm(prems, desc='computing shards') if (val := validate_shard(perm))[0]
        ]
        expr_to_ineq.cache_clear()
        shard_validated = ()
        self._encoded_shards = [perm for perm, point in shard_validated]
        self._feasible_points = [point for _, point in shards_validated]
        return self._encoded_shards

    def get_shards(self) -> List[Shard]:
        if self._shards is None:
            self._shards = [Shard(shard_id, self) for shard_id in self.get_encoded_shards()]
        return self._shards

    def compute_feasible_points(self) -> Tuple[Dict[ShardVec, List[Position]], List[Position]]:
        shards = self.get_shards()
        point_classification = {shard_id: [] for shard_id in self._encoded_shards}
        shifted = [list(np.floor(np.array(p) + np.array(self.shifts.as_list()))) for p in self._feasible_points]
        valid_shifted = []
        for shard, p in zip(shards, shifted):
            p = Position(p, self.symbols)
            if shard.in_space(p):
                point_classification[shard.shard_id].append(p)
                valid_shifted.append(p)
        return point_classification, valid_shifted

    def populate_cmf_start_points(self,
                                  use_feasible: bool = True,
                                  expand_anyway: bool = False,
                                  clear_original: bool = True,
                                  start_method: str = 'cube') -> None:
        """
        The function populates the CMF's start points with the points that are within the shards.

        The function preforms the following steps:
        * First, use the estimate radius using the feasible points found in the process of finding the shards.
        * If the first stage was unsuccessful, enlarge the set of potential starting points by adding
         a cube of an increasing edge length.
        :param use_feasible: Try using the points already generated when finding the shards.
        :param expand_anyway: Even if start points are found using the feasible points, expand the set of
         starting points.
        :param clear_original: Clear the currently found start points.
        :param start_method: The method to use for generating starting points
            (cube / sphere of a specified radius computed internally)
        """
        shards = self.get_shards()
        point_classification = {shard_id: [] for shard_id in self._encoded_shards}
        expansion_factor = np.sqrt(len(self.symbols))

        expand_search = use_feasible or expand_anyway
        valid_shifted = []

        # Start by computing the relevant feasible points if there are any
        if use_feasible:
            point_classification, valid_shifted = self.compute_feasible_points()
            for shard_id in point_classification:
                if len(point_classification[shard_id]) == 0:
                    expand_search = True
                    break
            if not expand_search and not expand_anyway:
                return

        first_iteration = True
        r = (max([linalg.norm(p) for p in valid_shifted]) if valid_shifted else 0) + expansion_factor
        points = PointGenerator.generate_via_shape(r, len(self.symbols), start_method, as_primitive=False)

        # Find possible start points within a cube
        while expand_search:
            expand_search = False

            if not first_iteration:
                points = PointGenerator.expand_set(points, signed_expansion=True, norm=r)
            first_iteration = False

            # classify points
            for point in points:
                point = list(np.array(point) + np.array(self.shifts))
                encoded, valid = self.encode_point(Position(point, self.symbols), self.hps)
                if not valid:
                    continue
                point_classification[encoded].append(Position(point))

            # make sure all shards have a start point
            for shard_id in point_classification:
                if len(point_classification[shard_id]) == 0:
                    r += expansion_factor
                    expand_search = True
                    break
        for shard in shards:
            if clear_original:
                shard.clear_start_points()
            shard.add_start_points(point_classification[shard.shard_id], filtering=False)

    @staticmethod
    def encode_point(point: Position, hps: List[Plane]) -> Tuple[ShardVec, bool]:
        """
        Encodes the shard that the point is within its borders.
        :param point: The point as a tuple
        :param hps: The hyperplanes defining the shards
        :return: The Shard encoding +-1's vector, True if the point is not on a hyperplane, else False.
        """
        def sign(n):
            if n == 0:
                return 0
            return 1 if n > 0 else -1
        return encoded := tuple(sign(plane.expression.subs(point)) for plane in hps), 0 not in encoded
