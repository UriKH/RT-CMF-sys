from utils.util_types import *
from utils.plane import Plane
from configs.analysis import *
from ramanujantools.cmf import CMF

from itertools import product
from functools import lru_cache
from scipy.optimize import linprog
import numpy as np


class ShardExtractor:
    """
    A functional class in charge of the Shards extraction for later use
    """
    def __init__(self, cmf: CMF, shifts: List[Position]):
        self.cmf = cmf
        self.shifts = shifts
        self.hps, self.symbols = self.__extract_shard_hyperplanes(cmf)

    @staticmethod
    def __extract_shard_hyperplanes(cmf: CMF) -> Tuple[List[Plane], List[sp.Symbol]]:
        """
        Extract the CMF's hyperplanes that form the shards
        :param cmf: The CMF to analyze
        :return: the list of sympy expressions describing the hyperplanes and a list of the symbols
        """

        def solve_shards(mat: sp.Matrix) -> Tuple[Set[EqTup], Set[EqTup]]:
            """
            Find the expressions for which the matrix is undefined or its determinant is 0
            :param mat: The matrix to preform the calculations on
            :return: The list of expressions for undefined hyperplanes (lhs, rhs);
            The list of expressions for zero determinant hyperplanes (lhs, rhs)
            """
            l = []
            for v in mat.iter_values():
                if (den := v.as_numer_denom()[1]) == 1:
                    continue
                l += [{sym: sol} for sym in den.free_symbols for sol in sp.solve(den, sym)]
            return freeze(l), freeze(sp.solve(mat.det()))

        def freeze(l: List[Dict]) -> Set[EqTup]:
            """
            Convert a list of dictionaries generated by sympy.solve() into a set of lhs, rhs tuples
            :param l: The list of dictionaries to transform
            :return: The transformed list
            """
            return set(tuple(set(sol.items()))[0] for sol in l)

        def unfreeze(l: Set[EqTup]) -> List[EqTup]:
            """
            Converts the set of tuples (lhs, rhs) into a list of tuples such that we won't have doubles (filtering).
            :param l: The list to "unfreeze"
            :return: The filtered list of tuples (lhs, rhs)
            """
            clean = [set(tup) for tup in l]
            new_lst = set(tuple(tup) for tup in clean)
            return list(new_lst)  # type checker shouts, but this is correct!

        data = set()
        for mat in cmf.matrices.values():
            undef, z_det = solve_shards(mat)
            data = data.union(z_det.union(undef))
        data = unfreeze(data)
        symbols = list(cmf.matrices.keys())
        return [Plane(exp1 - exp2, symbols) for exp1, exp2 in data], symbols

    def get_shards(self) -> List[ShardVec]:
        """
        Compute the Shards as Shard vector identifiers
        :return: A list of the vector identifiers
        """
        @lru_cache(maxsize=128 if SHARD_EXTRACTOR_CACHE else 0)
        def expr_to_ineq(expr, greater_than_0: bool = True):
            """
            Prepare a linear expression of the form: ax + b > 0 \n
            to the form scipy.linprog() receives: -ax <= b - err \n
            (similarly for ax + b < 0: ax <= -b - err)
            :param expr: The expression to transform into the relevant inequality
            :param greater_than_0: indicates the format
            :return: the row matching the expression and the constant in the scipy.linprog() format
            """
            coeffs = expr.as_coefficients_dict()
            sign = 1 if greater_than_0 else -1
            row = [-sign * coeffs.get(v, 0) for v in self.symbols]
            b = sign * coeffs.get(1, 0) - SHARD_EXTRACTOR_ERR
            return row, b

        def validate_shard(shard: ShardVec) -> bool:
            """
            Checks if a shard vector is valid in the CMF
            :param shard: the shard vector +-1's vector that describes the shard
            :return: True if a corresponding shard exsits, else False
            """
            A, b = [], []
            for ineq, indicator in zip(self.hps, shard):
                row, rhs = expr_to_ineq(ineq, indicator == 1)
                A.append(row)
                b.append(rhs)
            return linprog(c=list(np.zeros(len(self.symbols))), A_ub=A, b_ub=b, method="highs").success

        res = [permutation for permutation in product([+1, -1], repeat=len(self.hps)) if
               validate_shard(permutation)]
        expr_to_ineq.cache_clear()
        return res

    def populate_shards(self) -> None:
        """
        1. Create a set of points - potential start points (with respect to the shifts)
        2. Sort the start points to Shards
        3. Create a set of points - potential trajectories
        4. Sort the trajectories to Shards
        """
        raise NotImplementedError
